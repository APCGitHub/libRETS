<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libRETS: librets: A C++ RETS Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libRETS
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">librets: A C++ RETS Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>librets is a C++ RETS library. It provides support for logging in, logging out, searching, and metadata retrieval. The main interface is through the <a class="el" href="classlibrets_1_1_rets_session.html" title="RetsSession contains the API that is the main controlling interface to the RETS server. ">librets::RetsSession</a> class.</p>
<p>Here is an example demonstrating searching:</p>
<pre class="fragment">#include "librets.h"
#include &lt;iostream&gt;

using namespace librets;
using std::cout;
using std::cerr;
using std::endl;

int main(int argc, char * argv[])
{
    try
    {
        RetsSessionPtr session(
            new RetsSession("http://demo.crt.realtors.org:6103/rets/login"));
        session-&gt;Login("Joe", "Schmoe");
        
        if (session-&gt;GetDetectedRetsVersion() != session-&gt;GetRetsVersion())
        {
            cout &lt;&lt; "** Warning, requested RETS version \"" 
                 &lt;&lt; session-&gt;RetsVersionToString(session-&gt;GetRetsVersion())
                 &lt;&lt; "\", got version \""
                 &lt;&lt; session-&gt;RetsVersionToString(session-&gt;GetDetectedRetsVersion())
                 &lt;&lt; "\" ** " &lt;&lt; endl;
        }

        SearchRequestAPtr searchRequest(
            new SearchRequest("Property", "RES", 
                              "(ListPrice=300000-)"));
        
        SearchResultSetAPtr results = session-&gt;Search(searchRequest.get());
        while (results-&gt;HasNext())
        {
            cout &lt;&lt; "ListingID: " &lt;&lt; results-&gt;GetString("ListingID") &lt;&lt; endl;
            cout &lt;&lt; "ListPrice: " &lt;&lt; results-&gt;GetString("ListPrice") &lt;&lt; endl;
            cout &lt;&lt; " Bedrooms: " &lt;&lt; results-&gt;GetString("Bedrooms") &lt;&lt; endl;
            cout &lt;&lt; "     City: " &lt;&lt; results-&gt;GetString("City") &lt;&lt; endl;
            cout &lt;&lt; endl;
        }
        
        session-&gt;Logout();
    }
    catch (RetsException &amp; e)
    {
        e.PrintFullReport(cerr);
    }
}
</pre><p>Here is an example showing how to use metadata:</p>
<pre class="fragment">/*
 * Copyright (C) 2005-2009 National Association of REALTORS(R)
 *
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished
 * to do so, provided that the above copyright notice(s) and this
 * permission notice appear in all copies of the Software and that
 * both the above copyright notice(s) and this permission notice
 * appear in supporting documentation.
 */

#include "librets.h"
#include "Options.h"
#include &lt;iostream&gt;

using namespace librets;
using std::string;
using std::vector;
using std::cout;
using std::endl;
using std::exception;

void dumpSystem(RetsMetadata * metadata);
void dumpAllForeignKeys(RetsMetadata * metadata);
void dumpAllResources(RetsMetadata * metadata);
void dumpAllClasses(RetsMetadata * metadata, MetadataResource * resource);
void dumpAllTables(RetsMetadata * metadata, MetadataClass * aClass);
void dumpAllLookups(RetsMetadata * metadata, MetadataResource * resource);
void dumpAllLookupTypes(RetsMetadata * metadata, MetadataLookup * lookup);

int main(int argc, char * argv[])
{
    try
    {
        Options options;
        if (!options.ParseCommandLine(argc, argv))
        {
            return 0;
        }

        RetsSessionPtr session = options.RetsLogin();
        if (!session)
        {
            cout &lt;&lt; "Login failed\n";
            return -1;
        }

        if (session-&gt;GetDetectedRetsVersion() != session-&gt;GetRetsVersion())
        {
            cout &lt;&lt; "** Warning, requested RETS version \"" 
                 &lt;&lt; session-&gt;RetsVersionToString(session-&gt;GetRetsVersion())
                 &lt;&lt; "\", got version \""
                 &lt;&lt; session-&gt;RetsVersionToString(session-&gt;GetDetectedRetsVersion())
                 &lt;&lt; "\" ** " &lt;&lt; endl;
        }
        
        if (session-&gt;GetDetectedRetsVersion() == RETS_1_7)
        {
            try
            {
                ServerInformationResponseAPtr serverInfo = session-&gt;GetServerInformation();
                
                if (serverInfo.get())
                {
                    StringVector parameters = serverInfo-&gt;GetParameters();
                    StringVector::const_iterator i;
                    for (i = parameters.begin(); i != parameters.end(); i++)
                    {
                        if (i-&gt;empty())
                        {
                            continue;
                        }
                        cout &lt;&lt; *i &lt;&lt; ": " &lt;&lt; serverInfo-&gt;GetValue(*i) &lt;&lt; endl;
                    }
                }
            }
            catch (RetsException &amp; e)
            {
               /*
                * The ServerInformation Transaction is not supported.
                * Continue silently.
                */
            }
        }

        RetsMetadata * metadata = session-&gt;GetMetadata();
        dumpSystem(metadata);
        dumpAllForeignKeys(metadata);
        dumpAllResources(metadata);

        session-&gt;Logout();
    }
    catch (RetsException &amp; e)
    {
        e.PrintFullReport(cout);
        return 1;
    }
    catch (exception &amp; e)
    {
        cout &lt;&lt; e.what() &lt;&lt; endl;
        return 2;
    }
    return 0;
}

void dumpSystem(RetsMetadata * metadata)
{
    MetadataSystem * system = metadata-&gt;GetSystem();
    cout &lt;&lt; "System ID: " &lt;&lt; system-&gt;GetSystemID() &lt;&lt; endl;
    cout &lt;&lt; "System Description: " &lt;&lt; system-&gt;GetSystemDescription() &lt;&lt; endl;
    cout &lt;&lt; "Comments: " &lt;&lt; system-&gt;GetComments() &lt;&lt; endl;
}

void dumpAllForeignKeys(RetsMetadata * metadata)
{
    MetadataForeignKeyList foreign_keys = metadata-&gt;GetAllForeignKeys();
    MetadataForeignKeyList::iterator i;
    cout &lt;&lt; endl;
    for (i = foreign_keys.begin(); i != foreign_keys.end(); i++)
    {
        MetadataForeignKey * foreign_key = *i;
        
        cout &lt;&lt; "Foreign Key ID:" &lt;&lt; foreign_key-&gt;GetForeignKeyID() &lt;&lt; endl;
        cout &lt;&lt; "  Parent Resource: " &lt;&lt; foreign_key-&gt;GetParentResourceID();
        cout &lt;&lt; ", Class: " &lt;&lt; foreign_key-&gt;GetParentClassID();
        cout &lt;&lt; ", Name: " &lt;&lt; foreign_key-&gt;GetParentSystemName() &lt;&lt; endl;
        cout &lt;&lt; "  Child Resource: " &lt;&lt; foreign_key-&gt;GetChildResourceID();
        cout &lt;&lt; ", Class: " &lt;&lt; foreign_key-&gt;GetChildClassID();
        cout &lt;&lt; ", Name: " &lt;&lt; foreign_key-&gt;GetChildSystemName() &lt;&lt; endl;
    }
}

void dumpAllResources(RetsMetadata * metadata)
{
    MetadataResourceList resources = metadata-&gt;GetAllResources();
    MetadataResourceList::iterator i;
    cout &lt;&lt; endl;
    for (i = resources.begin(); i != resources.end(); i++)
    {
        MetadataResource * resource = *i;
        dumpAllClasses(metadata, resource);
    }

    for (i = resources.begin(); i != resources.end(); i++)
    {
        MetadataResource * resource = *i;
        dumpAllLookups(metadata, resource);
    }
}



void dumpAllClasses(RetsMetadata * metadata, MetadataResource * resource)
{
    string resourceName = resource-&gt;GetResourceID();
    
    MetadataClassList classes =
        metadata-&gt;GetAllClasses(resourceName);
    MetadataClassList::iterator i;
    for (i = classes.begin(); i != classes.end(); i++)
    {
        MetadataClass * aClass = *i;
        cout &lt;&lt; "Resource name: " &lt;&lt; resourceName &lt;&lt; " ["
             &lt;&lt; resource-&gt;GetStandardName() &lt;&lt; "]" &lt;&lt; endl;
        cout &lt;&lt; "Class name: " &lt;&lt; aClass-&gt;GetClassName() &lt;&lt; " ["
             &lt;&lt; aClass-&gt;GetStandardName() &lt;&lt; "]" &lt;&lt; endl;
        dumpAllTables(metadata, aClass);
        cout &lt;&lt; endl;
    }
}

void dumpAllTables(RetsMetadata * metadata, MetadataClass * aClass)
{
    MetadataTableList tables = metadata-&gt;GetAllTables(aClass);
    MetadataTableList::iterator i;
    for (i = tables.begin(); i != tables.end(); i++)
    {
        MetadataTable * table = *i;
        cout &lt;&lt; "Table name: " &lt;&lt; table-&gt;GetSystemName() &lt;&lt; " ["
             &lt;&lt; table-&gt;GetStandardName() &lt;&lt; "]" &lt;&lt; " ("
             &lt;&lt; table-&gt;GetDataType() &lt;&lt; ")";
        if (!table-&gt;GetMetadataEntryID().empty())
        {
            cout &lt;&lt; " MetadataEntryID: " &lt;&lt; table-&gt;GetMetadataEntryID();
        }
        if (table-&gt;InKeyIndex())
        {
            cout &lt;&lt; " InKeyIndex";
        }
        cout &lt;&lt; endl;
    }
}

void dumpAllLookups(RetsMetadata * metadata, MetadataResource * resource)
{
    string resourceName = resource-&gt;GetResourceID();
    
    MetadataLookupList classes =
        metadata-&gt;GetAllLookups(resourceName);
    MetadataLookupList::iterator i;
    for (i = classes.begin(); i != classes.end(); i++)
    {
        MetadataLookup * lookup = *i;
        cout &lt;&lt; "Resource name: " &lt;&lt; resourceName &lt;&lt; " ["
             &lt;&lt; resource-&gt;GetStandardName() &lt;&lt; "]" &lt;&lt; endl;
        cout &lt;&lt; "Lookup name: " &lt;&lt; lookup-&gt;GetLookupName() &lt;&lt; " ("
             &lt;&lt; lookup-&gt;GetVisibleName() &lt;&lt; ")";

        if (!lookup-&gt;GetMetadataEntryID().empty())
        {
            cout &lt;&lt; " MetadataEntryID: " &lt;&lt; lookup-&gt;GetMetadataEntryID();
        }
            
        cout &lt;&lt; endl;
        dumpAllLookupTypes(metadata, lookup);
        cout &lt;&lt; endl;
    }
}

void dumpAllLookupTypes(RetsMetadata * metadata, MetadataLookup * lookup)
{
    MetadataLookupTypeList lookupTypes = metadata-&gt;GetAllLookupTypes(lookup);
    MetadataLookupTypeList::const_iterator i ;
    for (i = lookupTypes.begin(); i != lookupTypes.end(); i++)
    {
        MetadataLookupType * lookupType = *i;
        cout &lt;&lt; "Lookup value: " &lt;&lt; lookupType-&gt;GetValue() &lt;&lt; " ("
             &lt;&lt; lookupType-&gt;GetShortValue() &lt;&lt; ", "
             &lt;&lt; lookupType-&gt;GetLongValue() &lt;&lt; ")"; 

        if (!lookupType-&gt;GetMetadataEntryID().empty())
        {
            cout &lt;&lt; " MetadataEntryID: " &lt;&lt; lookupType-&gt;GetMetadataEntryID();
        }
       
        cout &lt;&lt; endl;
    }
}
</pre><p>Lastly, here is an example showing more sophisticated usage. In this example, metadata is searched to determine the key field for the given resource and class. If this is a RETS 1.7 and later server, then the timestamp field is also determined from metadata. If pre RETS 1.7, then the user must provide the name of the timetsamp field. By default, and using the demo server, this example will search residential property listings.</p>
<p>Using the keyfield, all listings are returned that have been changed since the specified timestamp. The first search only returns the keyfield. The reason for this is that many servers limit the amount of data to be returned at any one time. If more columns are returned, less total listings can be returned. The intent is that given only the keyfield, we should be able to retrieve all the keys since the date in the timestamp.</p>
<p>Next, using the keyfield, the full listing is fetched and returned. Then all of the Photos for that listing are retrieved and their names displayed.</p>
<pre class="fragment">/*
 * Copyright (C) 2008 National Association of REALTORS(R)
 *
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished
 * to do so, provided that the above copyright notice(s) and this
 * permission notice appear in all copies of the Software and that
 * both the above copyright notice(s) and this permission notice
 * appear in supporting documentation.
 */

#include "librets.h"
#include "Options.h"
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;boost/date_time.hpp&gt;
#include "librets/str_stream.h"

using namespace librets;
using std::cout;
using std::cerr;
using std::endl;
using std::string;
using std::stringstream;
using std::setw;
using std::vector;
namespace po = boost::program_options;

int main(int argc, char * argv[])
{
    try
    {
        string                      classTimeStamp;
        SearchRequest::CountType    count;
        string                      countString;
        int                         defaultLimit = SearchRequest::LIMIT_DEFAULT;
        int                         defaultOffset = SearchRequest::OFFSET_NONE;
        SearchRequest::FormatType   format = SearchRequest::COMPACT_DECODED;
        string                      keyField;
        string                      lastModified;
        vector&lt;string&gt;              listingIds;
        int                         limit;
        RetsMetadata *              metadata;
        MetadataClass *             metadataClass;
        MetadataResource *          metadataResource;
        int                         offset;
        bool                        printCount;
        string                      query;
        string                      resource;
        string                      searchClass;
        SearchRequestAPtr           searchRequest;
        string                      select;
        bool                        standardNames = true;
        int                         totalListings = 0;
        string                      type;

        Options options;
        options.descriptions.add_options()
            ("resource,r", po::value&lt;string&gt;(&amp;resource)
             -&gt;default_value("Property"), "Search resource")
            ("class,C", po::value&lt;string&gt;(&amp;searchClass)
             -&gt;default_value("RES"), "Search class")
            ("timestamp,T", po::value&lt;string&gt;(&amp;classTimeStamp)
             -&gt;default_value(""), "Systemname of the Class TimeStamp field")
             ("lastmodified,L", po::value&lt;string&gt;(&amp;lastModified)
              -&gt;default_value(""), "RETS timestamp of the earliest date from which to select")
            ("select,s", po::value&lt;string&gt;(&amp;select)
             -&gt;default_value("ListingID,ListPrice,Beds,City"), "Search select")
            ("query,q", po::value&lt;string&gt;(&amp;query)
             -&gt;default_value("(ListPrice=300000-)"), "Search query")
            ("system-names,S", "Use system names, instead of standard names")
            ("type,t", po::value&lt;string&gt;(&amp;type)
             -&gt;default_value("Photo"), "Media Type")
            ("compact", "Use COMPACT instead of COMPACT-DECODED")
            ("limit,L", po::value&lt;int&gt;(&amp;limit)
             -&gt;default_value(defaultLimit), "Set the limit")
            ("offset,O", po::value&lt;int&gt;(&amp;offset)
             -&gt;default_value(defaultOffset), "Set the offset")
            ("count,n", po::value&lt;string&gt;(&amp;countString)
             -&gt;default_value("yes"),
             "Set the count type: no, yes or count-only)")
            ;
        if (!options.ParseCommandLine(argc, argv))
        {
            return 0;
        }
        if (options.count("system-names"))
        {
            standardNames = false;
        }
        if (options.count("compact"))
        {
            format = SearchRequest::COMPACT;
        }
        
        if (countString == "yes")
        {
            count = SearchRequest::RECORD_COUNT_AND_RESULTS;
            printCount = true;
        }
        else if (countString == "no")
        {
            count = SearchRequest::NO_RECORD_COUNT;
            printCount = false;
        }
        else if (countString == "count-only")
        {
            count = SearchRequest::RECORD_COUNT_ONLY;
            printCount = true;
        }
        else
        {
            count = SearchRequest::RECORD_COUNT_AND_RESULTS;
            printCount = true;
        }

        RetsSessionPtr session = options.RetsLogin();
        if (!session)
        {
            cout &lt;&lt; "Login failed\n";
            return -1;
        }
        
        /*
         * Find the keyfield for the resource.
         */
        metadata = session-&gt;GetMetadata();
        metadataResource = metadata-&gt;GetResource(resource);
        if (metadataResource == NULL)
        {
            cout &lt;&lt; "Invalid resource: " &lt;&lt; resource &lt;&lt; std::endl;
            session-&gt;Logout();
            return -1;
        }
        keyField = metadataResource-&gt;GetKeyField();
        
        /*
         * Find the timetsamp field if it is known (RETS 1.7 and later). If 
         * not known, the user must provide it.
         */
        metadataClass = metadata-&gt;GetClass(resource, searchClass);
        if (metadataClass == NULL)
        {
            cout &lt;&lt; "Invalid resource:class: "
                 &lt;&lt; resource
                 &lt;&lt; ":"
                 &lt;&lt; searchClass 
                 &lt;&lt; std::endl;
            session-&gt;Logout();
            return -1;
        }
        if (classTimeStamp.length() == 0)
            classTimeStamp = metadataClass-&gt;GetStringAttribute("ClassTimeStamp");
            
        if (classTimeStamp.length() == 0)
        {
            cout &lt;&lt; "Class "
                 &lt;&lt; resource
                 &lt;&lt; ":"
                 &lt;&lt; searchClass
                 &lt;&lt; " has no ClassTimeStamp specified in the metadata. "
                 &lt;&lt; std::endl
                 &lt;&lt; "Please manually provide one using the --timestamp switch."
                 &lt;&lt; std::endl;
            session-&gt;Logout();
            return -1;
        }
        
        /*
         * See if the last modified timestamp has been provided. If not, take the
         * current time less 24 hours.
         */
        if (lastModified.length() == 0)
        {
            stringstream ss;
            boost::gregorian::date_facet *output_facet = new boost::gregorian::date_facet("%Y-%m-%d");
            ss.imbue(std::locale(std::locale::classic(), output_facet));
            boost::gregorian::date d(boost::gregorian::day_clock::local_day());
            d -= boost::gregorian::days(1);
            ss &lt;&lt; d;
            lastModified = ss.str();
        }
        
        /*
         * OK - let's find all listings that have changed since the lastModified date
         */

        /*
         * Construct the query.
         */
        searchRequest = session-&gt;CreateSearchRequest(
                                    resource, searchClass,
                                    str_stream()    &lt;&lt; "("
                                                    &lt;&lt; classTimeStamp
                                                    &lt;&lt; "="
                                                    &lt;&lt; lastModified
                                                    &lt;&lt; "+)");

        searchRequest-&gt;SetSelect(keyField);
        /*
         * Must use system names for this search.
         */
        searchRequest-&gt;SetStandardNames(false);
        searchRequest-&gt;SetLimit(SearchRequest::LIMIT_DEFAULT);
        searchRequest-&gt;SetOffset(SearchRequest::OFFSET_NONE);
        searchRequest-&gt;SetCountType(SearchRequest::RECORD_COUNT_AND_RESULTS);
        searchRequest-&gt;SetFormatType(SearchRequest::COMPACT);
        
        SearchResultSetAPtr results = session-&gt;Search(searchRequest.get());
        if (printCount)
        {
            cout &lt;&lt; "Matching record count: " &lt;&lt; results-&gt;GetCount() &lt;&lt; endl;
        }
        /*
         * For all listings found, fetch the full listing detail and then the 
         * associated Photos.
         */
        while (results-&gt;HasNext())
        {
            totalListings++;
            listingIds.push_back(results-&gt;GetString(keyField));
            /*
             * Create a new search to fetch all the detail for the listing.
             */   
            SearchRequestAPtr   listingRequest = session-&gt;CreateSearchRequest(
                                                            resource,
                                                            searchClass,
                                                            str_stream()    &lt;&lt; "("
                                                                            &lt;&lt; keyField
                                                                            &lt;&lt; "="
                                                                            &lt;&lt; results-&gt;GetString(keyField)
                                                                            &lt;&lt; ")");
            listingRequest-&gt;SetStandardNames(false);
            listingRequest-&gt;SetLimit(SearchRequest::LIMIT_DEFAULT);
            listingRequest-&gt;SetOffset(SearchRequest::OFFSET_NONE);
            listingRequest-&gt;SetCountType(SearchRequest::NO_RECORD_COUNT);
            listingRequest-&gt;SetFormatType(SearchRequest::COMPACT);
            
            SearchResultSetAPtr listingResult = session-&gt;Search(listingRequest.get());
            StringVector columns = listingResult-&gt;GetColumns();
            
            while (listingResult-&gt;HasNext())
            {
                /*
                 * Show the listing detail.
                 */
                for (StringVector::iterator i = columns.begin(); i != columns.end(); i++)
                {
                    string column = *i;
                    cout &lt;&lt; setw(15) &lt;&lt; column &lt;&lt; ": "
                        &lt;&lt; setw(0) &lt;&lt; listingResult-&gt;GetString(column) &lt;&lt; endl;
                }
            }
            
            /*
             * Now set up to fetch the objects associated with this listing.
             */
            GetObjectRequest getObjectRequest(resource, type);
            getObjectRequest.AddAllObjects(results-&gt;GetString(keyField));
            
            GetObjectResponseAPtr   getObjectResponse = session-&gt;GetObject(&amp;getObjectRequest);
            
            ObjectDescriptor * objectDescriptor;
            while ((objectDescriptor = getObjectResponse-&gt;NextObject()))
            {
                /*
                 * Report the object details.
                 */
                string  objectKey   = objectDescriptor-&gt;GetObjectKey();
                int     objectId    = objectDescriptor-&gt;GetObjectId();
                string  contentType = objectDescriptor-&gt;GetContentType();
                string  description = objectDescriptor-&gt;GetDescription();
                int     replyCode   = objectDescriptor-&gt;GetRetsReplyCode();
                string  replyText   = objectDescriptor-&gt;GetRetsReplyText();
                
                cout &lt;&lt; "Object "
                     &lt;&lt; objectKey
                     &lt;&lt; ":"
                     &lt;&lt; objectId;
                if (!description.empty())
                    cout &lt;&lt; ", description: "
                         &lt;&lt; description;
                cout &lt;&lt; endl;
                
                if (replyCode != 0)
                    cout &lt;&lt; "***: "
                         &lt;&lt; replyCode
                         &lt;&lt; ": "
                         &lt;&lt; replyText
                         &lt;&lt; endl;
            }
            cout &lt;&lt; endl;
        }
        cout &lt;&lt; "Total Listings Retrieved: " &lt;&lt; totalListings &lt;&lt; endl;
        cout &lt;&lt; "Listing IDs:" &lt;&lt; endl;
        
        for (vector&lt;string&gt;::iterator i = listingIds.begin(); i != listingIds.end(); i++)
            cout &lt;&lt; *i &lt;&lt; endl;
        
        session-&gt;Logout();
    }
    catch (RetsException &amp; e)
    {
        e.PrintFullReport(cerr);
    }
    catch (std::exception &amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
    }
}
</pre><p>Here is the same example using the .NET language C#:</p>
<pre class="fragment">using System;
using System.Collections;
using System.IO;
using System.Collections.Specialized;
using librets;

public class Interleaved
{
    /*
     * This class demonstrates the interleaving of search transactions.
     */
    static void Main(string[] args)
    {
        Options options  = new Options();

        if (!options.Parse(args))
            Environment.Exit(1);

        RetsSession session = options.SessionFactory();

        try {

            if (!session.Login(options.user_name, options.user_password))
            {
                Console.WriteLine("Invalid login");
                Environment.Exit(1);
            }
        } catch (Exception e)
        {
            Console.WriteLine("RetsException: " + e);
            Environment.Exit(1);
        }

        RetsVersion version = session.GetDetectedRetsVersion();
        Console.WriteLine("RETS Version: " +
            ((version == RetsVersion.RETS_1_5) ? "1.5" : 
            ((version == RetsVersion.RETS_1_7) ? "1.7" : "1.0")));

        /*
         * Find the key field for the resource.
         */
        RetsMetadata metadata = session.GetMetadata();
        MetadataResource metadataResource = metadata.GetResource(options.search_type);

        if (metadataResource == null)
        {
            Console.WriteLine("Invalid resource: " + options.search_type);
            session.Logout();
            Environment.Exit(1);
        }

        string keyField = metadataResource.GetKeyField();

        /*
         * Find the timestamp field if it is known (RETS 1.7 and later). If
         * not known, then the user must provide it.
         */
        MetadataClass metadataClass = metadata.GetClass(options.search_type, options.search_class);
        if (metadataClass == null)
        {
            Console.WriteLine("Invalid resource:class: " + options.search_type + ":" + options.search_class);
            session.Logout();
            Environment.Exit(2);
        }

        if (options.classTimeStamp != null &amp;&amp; options.classTimeStamp.Length == 0)
            options.classTimeStamp = metadataClass.GetStringAttribute("ClassTimeStamp");

        if (options.classTimeStamp == null || options.classTimeStamp.Length == 0)
        {
            Console.WriteLine("Class " + options.search_type +
                                  ":" + options.search_class +
                              " has no ClassTimeStamp specified in the metadata.");
            Console.WriteLine("Please manually provide one using the --timetsamp switch.");
            session.Logout();
            Environment.Exit(2);
        }
        
        /*
         * See if the last modified timestamp has been provided. If not, use yesterday.
         */
        if (options.lastModified == null || options.lastModified.Length == 0)
        {
            DateTime ts = DateTime.Now;

            options.lastModified = ts.AddDays(-1).ToString("yyyy-MM-dd");
        }

        /*
         * OK - let's find all listings that have changed since the lastModified date.
         */
        
        SearchRequest searchRequest = session.CreateSearchRequest(
                                                options.search_type, 
                                                options.search_class,
                                                "(" + 
                                                options.classTimeStamp.ToString() + 
                                                "=" +
                                                options.lastModified.ToString() +
                                                "+)");

        searchRequest.SetSelect(keyField);
        searchRequest.SetLimit(SearchRequest.LIMIT_NONE);
        searchRequest.SetOffset(SearchRequest.OFFSET_NONE);
        searchRequest.SetCountType(SearchRequest.CountType.RECORD_COUNT_AND_RESULTS);
        searchRequest.SetStandardNames(false);

        /*
         * This starts the outer search. 
         */
        SearchResultSet results = session.Search(searchRequest);
        
        Console.WriteLine("Record count: " + results.GetCount());
        Console.WriteLine();

        while (results.HasNext())
        {
            /*
             * Fetch the listing detail and media. This will cause a separate search transaction
             * to be open within the outer search transaction.
             */
            SearchRequest listingRequest = session.CreateSearchRequest(
                                                            options.search_type,
                                                            options.search_class,
                                                            "(" +
                                                            keyField +
                                                            "=" +
                                                            results.GetString(keyField) +
                                                            ")");
            listingRequest.SetStandardNames(false);
            listingRequest.SetLimit(SearchRequest.LIMIT_DEFAULT);
            listingRequest.SetOffset(SearchRequest.OFFSET_NONE);
            listingRequest.SetCountType(SearchRequest.CountType.NO_RECORD_COUNT);
            listingRequest.SetFormatType(SearchRequest.FormatType.COMPACT);
            
            SearchResultSet listingResult = session.Search(listingRequest);
            IEnumerable  columns = null;
            
            while (listingResult.HasNext())
            {
                if (columns == null)
                {
                    columns = listingResult.GetColumns();
                }
                /*
                 * Show the listing detail.
                 */
                foreach (string column in columns)
                {
                    Console.WriteLine("{0,15}: {1}", column, listingResult.GetString(column));
                }
                Console.WriteLine();
            
                /*
                 * Now set up to fetch the objects associated with this listing.
                 */
                GetObjectRequest getObjectRequest = new GetObjectRequest(options.search_type, "Photo");
                getObjectRequest.AddAllObjects(listingResult.GetString(keyField));
                
                GetObjectResponse getObjectResponse = session.GetObject(getObjectRequest);
                
                foreach(ObjectDescriptor objectDescriptor in getObjectResponse)
                {
                    /*
                     * Report the object details.
                     */
                    string  objectKey   = objectDescriptor.GetObjectKey();
                    int     objectId    = objectDescriptor.GetObjectId();
                    //string  contentType = objectDescriptor.GetContentType();
                    string  description = objectDescriptor.GetDescription();
                    
                    Console.Write ("Object " + objectKey + ":" + objectId.ToString());
                    if (description.Length &gt; 0)
                        Console.Write (", description: " + description);
                    Console.WriteLine();
                }
                Console.WriteLine("=================");
            }
        }

        session.Logout();
    }

    
}
</pre> </div></div><!-- contents -->
<hr size="1">
<address style="align: right;">
  <small>Generated by&nbsp;
    <a href="http://www.doxygen.org/index.html">
      <img src="doxygen.png" alt="doxygen" align="middle" border="0"></a>
  </small>
</address>
</body>
</html>
